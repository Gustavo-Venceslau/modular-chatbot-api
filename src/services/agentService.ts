import { RunnableSequence, RunnableWithMessageHistory } from "@langchain/core/runnables";
import { RedisChatMessageHistory } from "@langchain/redis";
import { redisClient } from "src/adapters/client/RedisClient.ts";
import { classificationChain } from "src/agents/classificationAgent.ts";
import { generalChain } from "src/agents/generalAgent.ts";
import { mathChain } from "src/agents/mathAgent.ts";
import { AgentRequest, AgentResponse, AgentWork } from "src/types/Agent.ts";
import { randomUUID as uuid } from "crypto";
import z from "zod";
import { APIError } from "src/adapters/http/errors/APIError.ts";

export class AgentService {
  constructor() {}

  async generateResponse(payload: AgentRequest): Promise<AgentResponse>{
    let { message, user_id, conversation_id } = this.validatedPayload(payload);
    let source_agent_response = "";
    const agent_workflow: AgentWork[] = [];

    const user = await redisClient.json.get(`user:data:${user_id}`);

    // if(!user) throw new APIError(404, "User not found by user_id");

    if(!conversation_id) { conversation_id = uuid() }

    const mainChain = RunnableSequence.from([
      async (input: { input: string }) => {
        const topic = await classificationChain.invoke({ input: input.input });
        return {
          topic,
          original_input: input.input,
        };
      },
      async (stepResult: { topic: string; original_input: string }) => {
        if (stepResult.topic.toLowerCase().includes("matematica")) {
          agent_workflow.push({ agent: "RouterAgent", decision: "MathAgent" })
          agent_workflow.push({ agent: "MathAgent" });
          source_agent_response = "Text generated by the specialized agent.";

          return await mathChain.invoke({ input: stepResult.original_input });
        } else {
          agent_workflow.push({ agent: "RouterAgent", decision: "KnowledgeAgent" });
          source_agent_response = "Text generated by the general agent.";

          return await generalChain.invoke({ input: stepResult.original_input });
        }
      },
    ]);

    const chainWithHistory = new RunnableWithMessageHistory({
      runnable: mainChain,
      getMessageHistory: (sessionId) =>
        new RedisChatMessageHistory({
          sessionId,
          client: redisClient,
        }),
      inputMessagesKey: "input",
      historyMessagesKey: "history",
    });

    const response = await chainWithHistory.invoke(
      { input: message },
      {
        configurable: {
          sessionId: `${user_id}:history:${conversation_id}`,
        },
      }
    )

    await redisClient.quit();

    return {
      response,
      source_agent_response,
      agent_workflow,
    }
  }

  private validatedPayload(payload: AgentRequest): AgentRequest {
    const payloadSchema = z.object({
      message: z.string().min(1),
      user_id: z.uuid(),
      conversation_id: z.uuid().optional()
    });

    return payloadSchema.parse(payload);
  }
}